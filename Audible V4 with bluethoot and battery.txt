
#include <Wire.h>
#include <Adafruit_BMP280.h>
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <BLEDescriptor.h>
#include <Preferences.h>
#include <esp_wifi.h>
#include <Arduino.h>

// === Pins & Constants ===
const int BUZZER_PIN      = 1;
const int SDA_PIN         = 9;
const int SCL_PIN         = 21;
const int BOOT_BUTTON_PIN = 0;
// Pin used to measure battery voltage on the LilyGO T7S3 board.
// The board connects the LiPo through a resistor divider to GPIO2. The divider
// halves the cell voltage, so we double the measured voltage to get the true cell
// voltage. See LilyGO documentation and community discussionshttps://community.home-assistant.io/t/battery-status-on-lillygo-t7-s3/580327#:~:text=in%20the%20example%20projects,Currently%20it%20looks%20like%20this.
const int BATTERY_PIN     = 2;

constexpr float  SEA_LEVEL_PRESS      = 1013.25f;
constexpr unsigned long LONG_PRESS_MS    = 3000;
constexpr unsigned long LOOP_INTERVAL_MS = 250;
constexpr int    BUZZER_FREQ          = 2750;
constexpr int    BUZZER_RES           = 13;
constexpr int    BUZZER_DUTY          = 4095;

// === State & storage ===
Adafruit_BMP280 bmp;
Preferences      prefs;
float            baselineAlt = 0.0f;
float            thresholds[4], beepOn[4], beepOff[4];
float            last_delta_ft = 0.0f;

// NVS keys & human names
const char* thrKeys[4]  = {"t1","t2","t3","t4"};
const char* onKeys [4]  = {"o1","o2","o3","o4"};
const char* offKeys[4]  = {"f1","f2","f3","f4"};
const char* thrNames[4] = {
  "Zone 1 threshold (ft)",
  "Zone 2 threshold (ft)",
  "Zone 3 threshold (ft)",
  "Zone 4 threshold (ft)"
};
const char* onNames[4]  = {
  "Zone 1 beepâ€‘on (ms)",
  "Zone 2 beepâ€‘on (ms)",
  "Zone 3 beepâ€‘on (ms)",
  "Zone 4 beepâ€‘on (ms)"
};
const char* offNames[4] = {
  "Zone 1 beepâ€‘off (ms)",
  "Zone 2 beepâ€‘off (ms)",
  "Zone 3 beepâ€‘off (ms)",
  "Zone 4 beepâ€‘off (ms)"
};

// BLE UUIDs
#define SERVICE_UUID "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
static const char* THR_UUIDS[4] = {
  "0000a001-1212-efde-1523-785fef13d123",
  "0000a002-1212-efde-1523-785fef13d123",
  "0000a003-1212-efde-1523-785fef13d123",
  "0000a004-1212-efde-1523-785fef13d123"
};
static const char* ON_UUIDS[4] = {
  "0000b001-1212-efde-1523-785fef13d123",
  "0000b002-1212-efde-1523-785fef13d123",
  "0000b003-1212-efde-1523-785fef13d123",
  "0000b004-1212-efde-1523-785fef13d123"
};
static const char* OFF_UUIDS[4] = {
  "0000c001-1212-efde-1523-785fef13d123",
  "0000c002-1212-efde-1523-785fef13d123",
  "0000c003-1212-efde-1523-785fef13d123",
  "0000c004-1212-efde-1523-785fef13d123"
};

// Characteristic pointers
BLECharacteristic* thrChar[4];
BLECharacteristic* onChar [4];
BLECharacteristic* offChar[4];
BLECharacteristic* battChar;

// â€”â€“â€“â€“ Helpers â€”â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“â€“
void beep(int ms) {
  ledcWrite(BUZZER_PIN, BUZZER_DUTY);
  delay(ms);
  ledcWrite(BUZZER_PIN, 0);
}

float readAltitudeOnce() {
  bmp.takeForcedMeasurement();
  return bmp.readAltitude(SEA_LEVEL_PRESS);
}

// Read the LiPo battery voltage and convert it to a percentage.
// The T7S3 routes the battery through a 100k:100k divider to GPIO2. We use
// analogReadMilliVolts() with 11dB attenuation to get the raw voltage, then
// multiply by 2 to compensate for the divider. A fully charged LiPo is ~4.2V
// while an empty cell falls to about 3.0V. Values outside this range are clamped.
int getBatteryPercent() {
  // Read millivolts and convert to volts. analogReadMilliVolts() scales
  // automatically based on the global attenuation set in setup().
  float mv = analogReadMilliVolts(BATTERY_PIN);
  float voltage = (mv / 1000.0f) * 2.0f; // correct for divider

  // Clamp to expected LiPo range and convert to a percentage.
  const float minV = 3.0f;
  const float maxV = 4.2f;
  if (voltage < minV) voltage = minV;
  if (voltage > maxV) voltage = maxV;
  float percent = (voltage - minV) / (maxV - minV) * 100.0f;
  return (int)roundf(percent);
}

// Generic BLE write callback
struct ParamCB : public BLECharacteristicCallbacks {
  float*       arr;
  const char*  key;
  const char*  name;
  int          idx;
  ParamCB(float* a,const char* k,const char* n,int i)
    : arr(a), key(k), name(n), idx(i) {}
  void onWrite(BLECharacteristic* ch) override {
    float v = String(ch->getValue().c_str()).toFloat();
    arr[idx] = v;
    prefs.begin("params", false);
    prefs.putFloat(key, v);
    prefs.end();
    Serial.printf("ğŸ”§ %s = %.0f\n", name, v);
  }
};

// BLE server callbacks
class MyServerCB : public BLEServerCallbacks {
public:
  void onConnect(BLEServer*) override  { Serial.println("âœ… BLE client connected"); }
  void onDisconnect(BLEServer* s) override {
    Serial.println("âŒ BLE client disconnected");
    s->getAdvertising()->start();
  }
};

void setup() {
  // 1) Serial sanity check
  Serial.begin(115200);
  delay(500);
  Serial.println("âœ… code is running!");

  // 2) Sensors & baseline
  Wire.begin(SDA_PIN, SCL_PIN);
  esp_wifi_stop();           // powerâ€‘save
  if (!bmp.begin(0x76) && !bmp.begin(0x77)) {
    Serial.println("âŒ BMP280 missing!");
    while (1) delay(100);
  }
  bmp.setSampling(
    Adafruit_BMP280::MODE_FORCED,
    Adafruit_BMP280::SAMPLING_X2,
    Adafruit_BMP280::SAMPLING_X4,
    Adafruit_BMP280::FILTER_X4
  );
  baselineAlt = readAltitudeOnce();
  Serial.println("ğŸ¯ Baseline altitude calibrated");

  ledcAttach(BUZZER_PIN, BUZZER_FREQ, BUZZER_RES);

  // Configure ADC for battery measurement. Using 12â€‘bit resolution and
  // 11dB attenuation allows measurement up to ~3.9V. Because the T7S3 battery
  // divider halves the voltage, this range is sufficient for LiPo cellshttps://community.home-assistant.io/t/battery-status-on-lillygo-t7-s3/580327#:~:text=in%20the%20example%20projects,Currently%20it%20looks%20like%20this.
  analogReadResolution(12);
  analogSetAttenuation(ADC_11db);

  // 3) Load persisted or defaults
  float dthr[4] = {1000,3000,5500,7000},
        don [4] = {150,100,100,5000},
        doff[4] = {600,20,50,0};

  prefs.begin("params", false);
  for (int i = 0; i < 4; i++) {
    thresholds[i] = prefs.getFloat(thrKeys[i], dthr[i]);
    beepOn     [i] = prefs.getFloat(onKeys [i], don[i]);
    beepOff    [i] = prefs.getFloat(offKeys[i], doff[i]);
    Serial.printf("ğŸ“ˆ %s=%.0fft, %s=%.0fms, %s=%.0fms\n",
      thrNames[i], thresholds[i],
      onNames [i], beepOn[i],
      offNames[i], beepOff[i]
    );
  }
  prefs.end();

  // 4) BLE setup
  BLEDevice::init("MyAudible");
  BLEServer* server = BLEDevice::createServer();
  server->setCallbacks(new MyServerCB());

  // ***** CHANGE HERE: reserve ample handles (â‰¥ 49) *****
  BLEService* svc = server->createService(BLEUUID(SERVICE_UUID), 50);
  // *****************************************************

  // 5) Create all 12 characteristics in a loop
  for (int i = 0; i < 4; i++) {
    // threshold
    thrChar[i] = svc->createCharacteristic(
      THR_UUIDS[i],
      BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    thrChar[i]->setValue(String(thresholds[i]));
    thrChar[i]->setCallbacks(new ParamCB(thresholds, thrKeys[i], thrNames[i], i));
    { auto d = new BLEDescriptor(BLEUUID((uint16_t)0x2901));
      d->setValue(thrNames[i]);
      thrChar[i]->addDescriptor(d);
    }
    Serial.printf("Created %s\n", THR_UUIDS[i]);

    // beepâ€‘on
    onChar[i] = svc->createCharacteristic(
      ON_UUIDS[i],
      BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    onChar[i]->setValue(String(beepOn[i]));
    onChar[i]->setCallbacks(new ParamCB(beepOn, onKeys[i], onNames[i], i));
    { auto d = new BLEDescriptor(BLEUUID((uint16_t)0x2901));
      d->setValue(onNames[i]);
      onChar[i]->addDescriptor(d);
    }
    Serial.printf("Created %s\n", ON_UUIDS[i]);

    // beepâ€‘off
    offChar[i] = svc->createCharacteristic(
      OFF_UUIDS[i],
      BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_WRITE
    );
    offChar[i]->setValue(String(beepOff[i]));
    offChar[i]->setCallbacks(new ParamCB(beepOff, offKeys[i], offNames[i], i));
    { auto d = new BLEDescriptor(BLEUUID((uint16_t)0x2901));
      d->setValue(offNames[i]);
      offChar[i]->addDescriptor(d);
    }
    Serial.printf("Created %s\n", OFF_UUIDS[i]);
  }

  // Battery characteristic. Use a custom UUID separate from the zone parameters.
  // This characteristic exposes the battery percentage read from BATTERY_PIN.
  static const char* BATT_UUID = "0000d001-1212-efde-1523-785fef13d123";
  battChar = svc->createCharacteristic(
    BATT_UUID,
    BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_NOTIFY
  );
  // Set an initial value to avoid null reads on the client.
  battChar->setValue(String(getBatteryPercent()));
  {
    auto d = new BLEDescriptor(BLEUUID((uint16_t)0x2901));
    d->setValue("Battery (%)");
    battChar->addDescriptor(d);
  }

  svc->start();
  auto adv = server->getAdvertising();
  adv->addServiceUUID(svc->getUUID());
  adv->setScanResponse(true);
  adv->start();
  Serial.println("ğŸ“¡ Advertising as MyAudible");
}

void loop() {
  // longâ€‘press to recalibrate
  static bool lastBtn = HIGH;
  static unsigned long pressStart = 0;
  bool btn = digitalRead(BOOT_BUTTON_PIN);
  if (btn == LOW && lastBtn == HIGH) pressStart = millis();
  if (btn == LOW && (millis() - pressStart) >= LONG_PRESS_MS) {
    baselineAlt = readAltitudeOnce();
    Serial.println("ğŸ”„ Baseline recalibrated");
    beep(200); delay(100); beep(100);
    while (digitalRead(BOOT_BUTTON_PIN) == LOW) delay(10);
  }
  lastBtn = btn;

  // descentâ€‘only edge detection + beep patterns
  float delta_ft = (readAltitudeOnce() - baselineAlt) * 3.28084f;
  for (int i = 0; i < 4; i++) {
    if (last_delta_ft >= thresholds[i] && delta_ft < thresholds[i]) {
      if (beepOff[i] == 0) {
        beep((int)beepOn[i]);
      } else {
        int cnt = ceil(5000.0f / (beepOn[i] + beepOff[i]));
        for (int j = 0; j < cnt; j++) {
          beep((int)beepOn[i]);
          delay((int)beepOff[i]);
        }
      }
    }
  }
  last_delta_ft = delta_ft;
  delay(LOOP_INTERVAL_MS);

  // Periodically update the battery characteristic with the latest reading.
  // Without calling notify(), clients can still read the latest value manually.
  if (battChar != nullptr) {
    int pct = getBatteryPercent();
    battChar->setValue(String(pct));
    // Notify subscribed clients that the value has changed.
    battChar->notify();
  }
}
